<HTML>
<HEAD>
<TITLE>./tests/olympic-submission/ALICEADD/ALICEADD.user688.cpp</TITLE>
</HEAD>
<BODY BGCOLOR=white>
<HR>
./tests/olympic-submission/ALICEADD/ALICEADD.user579.cpp<p><PRE>
#include &lt;bits/stdc++.h&gt;
 
using namespace std;

#define ll long long
#define ull unsigned long long

struct BigNum {
    int ndigits;
    int sign;
    vector&lt;int&gt; digits;

    // Default constructor
    BigNum() : sign(0), ndigits(0), digits(vector&lt;int&gt;()) {}

    BigNum(long long x) {
        if (x &lt; 0) {
            this -&gt; sign = -1;
            x = -x;
        }
        else this -&gt; sign = 1;
        while (x &gt; 0) {
            this -&gt; digits.push_back(x % 10);
            x /= 10;
        }
        this -&gt; ndigits = (int) this -&gt; digits.size();
        reverse(this -&gt; digits.begin(), this -&gt; digits.end());
    }

    BigNum(string s) {
        if (s[0] == '-') {
            this -&gt; sign = -1;
            s.erase(0, 1);
        }
        else this -&gt; sign = 1;
        this -&gt; ndigits = (int) s.size();
        this -&gt; digits.resize(ndigits);
        for (int i = 0; i &lt; (int) s.size(); i++) {
            this -&gt; digits[i] = s[i] - '0';
        }
    }

    BigNum(vector&lt;int&gt; a) : sign(1), ndigits((int) a.size()), digits(a) {}

    // Comparison
    bool operator &lt; (const BigNum& other) const {
        if (sign != other.sign) return sign &lt; other.sign;
        if (ndigits != other.ndigits) return ndigits &lt; other.ndigits;
        for (int i = 0; i &lt; ndigits; i++) {
            if (digits[i] != other.digits[i]) {
                return digits[i] &lt; other.digits[i];
            }
        }
        return false;
    }

    bool operator &gt; (const BigNum& other) const {
        return other &lt; *this;
    }

    bool operator &gt;= (const BigNum& other) const {
        return !(*this &lt; other);
    }

<A NAME="4"></A><FONT color = #FF00FF><A HREF="match0-0.html#4" TARGET="0"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_4_1.gif" ALT="other" BORDER="0" ALIGN=left></A>

    bool operator &lt;= (const BigNum& other) const {
        return !(*this &gt; other);
    }

    bool operator == (const BigNum& other) const {
        return !(*this &lt; other) && !(*this &gt; other);
</FONT>    }

    bool operator != (const BigNum& other) const {
        return *this &lt; other || *this &gt; other;
    }

    // Other functions
    bool isZero() const {
        return digits.empty() || (ndigits == 1 && digits[0] == 0);
    }

    BigNum abs() const {
        BigNum ret = *this;
        if (isZero()) return ret;
        ret.sign *= ret.sign;
        return ret;
    }

    // Operations
    // Compare vector (compare bignum with sign ingnored)
    bool cmp_vec(const vector&lt;int&gt;& a, const vector&lt;int&gt;& b) {
        if (a.size() != b.size()) return a.size() &lt; b.size();
        for (int i = 0; i &lt; (int) a.size(); i++) {
            if (a[i] != b[i]) return a[i] &lt; b[i];
        }
        return false;
    }
    
    // Addition, return vector of digits, sign ignored.
    vector&lt;int&gt; add(const BigNum& a, const BigNum& b) {
        vector&lt;int&gt; da = a.digits, db = b.digits;
        if (!cmp_vec(da, db)) swap(da, db);
        reverse(da.begin(), da.end());
        reverse(db.begin(), db.end());
        vector&lt;int&gt; ret;
        int c = 0;
        for (int i = 0; i &lt; (int) da.size(); i++) {
            ret.push_back((da[i] + db[i] + c) % 10);
            c = (da[i] + db[i] + c) / 10;
        }
        for (int i = (int) da.size(); i &lt; (int) db.size(); i++) {
            ret.push_back((db[i] + c) % 10);
            c = (db[i] + c) / 10;
        }
        if (c &gt; 0) ret.push_back(c);
        while (!ret.empty() && ret.back() == 0) ret.pop_back();
        reverse(ret.begin(), ret.end());
        return ret;
    }

    // Subtraction, return vector of digits, sign ignored.
    vector&lt;int&gt; sub(const BigNum& a, const BigNum& b, bool& rev) {
        vector&lt;int&gt; da = a.digits, db = b.digits;
        if (cmp_vec(da, db)) {
            swap(da, db);
            rev = true;
        }
        reverse(da.begin(), da.end());
        reverse(db.begin(), db.end());
        vector&lt;int&gt; ret;
        int c = 0;
        for (int i = 0; i &lt; (int) db.size(); i++) {
            int v = (da[i] - db[i] - c);
            if (v &lt; 0) {
                v += 10; c = 1;
            }
            else c = 0;
            ret.push_back(v);
        }
        for (int i = (int) db.size(); i &lt; (int) da.size(); i++) {
            int v = da[i] - c;
            if (v &lt; 0) {
                v += 10; c = 1;
            }
            else c = 0;
            ret.push_back(v);
        }
        while (!ret.empty() && ret.back() == 0) ret.pop_back();
        reverse(ret.begin(), ret.end());
        return ret;
    }

    // Multiplication return vector of digits.
    static vector&lt;int&gt; simpleMultiply(const BigNum& a, const BigNum& b) {
        vector&lt;int&gt; res(a.digits.size() + b.digits.size(), 0);
        int ii = 0, jj = 0;
        for (int i = (int) a.digits.size() - 1; i &gt;= 0; i--) {
            int c = 0;
            jj = 0;
            for (int j = (int) b.digits.size() - 1; j &gt;= 0; j--) {
                int v = a.digits[i] * b.digits[j] + res[ii + jj] + c;
                c = v / 10;
                res[ii + jj] = v % 10;
                jj++;
            }
            if (c &gt; 0) res[ii + jj] += c;
            ii++;
        }
        res.shrink_to_fit();
        while (!res.empty() && res.back() == 0) res.pop_back();
        if (res.empty()) return {0};
        reverse(res.begin(), res.end());
        return res;
    }

    // Karatsuba multiplication of two vectors
    static vector&lt;long long&gt; karatsubaMultiply(const vector&lt;long long&gt;& a, const vector&lt;long long&gt;& b) {
        int n = (int) a.size();
<A NAME="1"></A><FONT color = #00FF00><A HREF="match0-0.html#1" TARGET="0"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_1_2.gif" ALT="other" BORDER="0" ALIGN=left></A>

        vector&lt;long long&gt; ret(n + n);
        if (n &lt;= 32) {
            for (int i = 0; i &lt; n; i++) {
                for (int j = 0; j &lt; n; j++) ret[i + j] += a[i] * b[j];
            }
            return ret;
        }
        int k = n &gt;&gt; 1;
</FONT>        vector&lt;long long&gt; a1(a.begin(), a.begin() + k);
        vector&lt;long long&gt; a2(a.begin() + k, a.end());
        vector&lt;long long&gt; b1(b.begin(), b.begin() + k);
        vector&lt;long long&gt; b2(b.begin() + k, b.end());
        vector&lt;long long&gt; a1b1 = karatsubaMultiply(a1, b1);
<A NAME="2"></A><FONT color = #0000FF><A HREF="match0-0.html#2" TARGET="0"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_2_1.gif" ALT="other" BORDER="0" ALIGN=left></A>

        vector&lt;long long&gt; a2b2 = karatsubaMultiply(a2, b2);
        for (int i = 0; i &lt; k; i++) a2[i] += a1[i];
        for (int i = 0; i &lt; k; i++) b2[i] += b1[i];
</FONT><A NAME="0"></A><FONT color = #FF0000><A HREF="match0-0.html#0" TARGET="0"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_0_5.gif" ALT="other" BORDER="0" ALIGN=left></A>

        vector&lt;long long&gt; r = karatsubaMultiply(a2, b2);
        for (int i = 0; i &lt; (int) a1b1.size(); i++) r[i] -= a1b1[i];
        for (int i = 0; i &lt; (int) a2b2.size(); i++) r[i] -= a2b2[i];
        for (int i = 0; i &lt; (int) r.size(); i++) ret[i + k] += r[i];
        for (int i = 0; i &lt; (int) a1b1.size(); i++) ret[i] += a1b1[i];
        for (int i = 0; i &lt; (int) a2b2.size(); i++) ret[i + n] += a2b2[i];
        return ret;
    }

    // Addition, with sign
    BigNum operator + (BigNum const& other) {
</FONT>        BigNum ret;
        if (sign == 1 && other.sign == 1) {
            vector&lt;int&gt; t = add(*this, other);
            ret.sign = 1;
            ret.ndigits = (int) t.size();
            ret.digits = t;
        }
        else if (sign == 1 && other.sign == -1) {
            bool rev = false;
            vector&lt;int&gt; t = sub(*this, other, rev);
            ret.sign = (rev ? -1 : 1);
            ret.ndigits = (int) t.size();
            ret.digits = t;
        }
        else if (sign == -1 && other.sign == 1) {
            bool rev = false;
            vector&lt;int&gt; t = sub(other, *this, rev);
            ret.sign = (rev ? -1 : 1);
            ret.ndigits = (int) t.size();
            ret.digits = t;
        }
        else {
            ret.sign = -1;
            vector&lt;int&gt; t = add(*this, other);
            ret.ndigits = (int) t.size();
            ret.digits = t;
        }
        return ret;
    }

    // Subtraction, with sign
    BigNum operator - (BigNum const& other) {
        BigNum ret;
        if (sign == 1 && other.sign == 1) {
            bool rev = false;
            vector&lt;int&gt; t = sub(*this, other, rev);
            ret.sign = (rev ? -1 : 1);
            ret.ndigits = (int) t.size();
            ret.digits = t;
        }
        else if (sign == 1 && other.sign == -1) {
            vector&lt;int&gt; t = add(*this, other);
            ret.sign = 1;
            ret.ndigits = (int) t.size();
            ret.digits = t;
        }
        else if (sign == -1 && other.sign == 1) {
            vector&lt;int&gt; t = add(*this, other);
            ret.sign = -1;
            ret.ndigits = (int) t.size();
            ret.digits = t;
        }
        else {
            bool rev = false;
            vector&lt;int&gt; t = sub(other, *this, rev);
            ret.sign = (rev ? -1 : 1);
            ret.ndigits = (int) t.size();
            ret.digits = t;
        }
        return ret;
    }

    // Multiplication
    BigNum mul_simple(const BigNum& v) const {
        BigNum ret;
        ret.sign = sign * v.sign;
        ret.digits = simpleMultiply(*this, v);
        ret.ndigits = (int) ret.digits.size();
        return ret;
    }

    BigNum mul_karatsuba(const BigNum& v) const {
        vector&lt;long long&gt; a(digits.rbegin(), digits.rend());
        vector&lt;long long&gt; b(v.digits.rbegin(), v.digits.rend());
<A NAME="3"></A><FONT color = #00FFFF><A HREF="match0-0.html#3" TARGET="0"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_3_1.gif" ALT="other" BORDER="0" ALIGN=left></A>

        while (a.size() &lt; b.size()) a.push_back(0);
        while (b.size() &lt; a.size()) b.push_back(0);
        // power of 2
        while (a.size() & (a.size() - 1)) {
            a.push_back(0);
</FONT>            b.push_back(0);
        }
        vector&lt;long long&gt; c = karatsubaMultiply(a, b);
        BigNum ret;
        ret.sign = sign * v.sign;
        int carry = 0;
<A NAME="5"></A><FONT color = #FF0000><A HREF="match0-0.html#5" TARGET="0"><IMG SRC="http://moss.stanford.edu/bitmaps/tm_0_1.gif" ALT="other" BORDER="0" ALIGN=left></A>

        for (int i = 0; i &lt; (int) c.size(); i++) {
            long long cur = c[i] + carry;
            ret.digits.push_back((int) cur % 10);
</FONT>            carry = cur / 10; 
        }
        while (carry &gt; 0) {
            ret.digits.push_back(carry % 10);
            carry /= 10;
        }
        while (!ret.digits.empty() && ret.digits.back() == 0) {
            ret.digits.pop_back();
        }
        reverse(ret.digits.begin(), ret.digits.end());
        ret.ndigits = (int) ret.digits.size();
        return ret;
    }

    BigNum operator * (BigNum const& other) {
        if (isZero() || other.isZero()) return BigNum(0);
        BigNum ret;
        ret.sign = sign * other.sign;
        if (digits.size() * other.digits.size() &lt;= 500000) return mul_simple(other);
        return mul_karatsuba(other);
    }

    void operator *= (const BigNum& other) {
        *this = *this * other;
    } 
};

void solve() {
    string sa, sb;
    cin &gt;&gt; sa &gt;&gt; sb;
    BigNum a = BigNum(sa), b = BigNum(sb);
    BigNum c = a + b;
    if (c.isZero()) cout &lt;&lt; 0 &lt;&lt; '\n';
    else {
        if (c.sign == -1) cout &lt;&lt; '-';
        for (int i : c.digits) cout &lt;&lt; i;
        cout &lt;&lt; '\n';
    }
}

int main() {
    ios::sync_with_stdio(0); cin.tie(0);

    int t;
    cin &gt;&gt; t;
    while (t--) {
        solve();
    }
}</PRE>
</PRE>
</BODY>
</HTML>
